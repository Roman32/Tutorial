---
title: Ruby tutorial
---
<div class="welcome">
  <h1>Ruby Tutorial for CSE 3901</h1>
  <br />
  <img  class="rubyLogo" src ="images/ruby.png" alt="ruby gem">
  <p class="rubyTitle"> Welcome to the Ruby tutorial for CSE 3901!</p>
  <p class="sectionTitle">Introduction:</p>
    <p class="writing"> 
    	The purpose of this tutorial is to ease you into the use of the Ruby programming language which is used heavily in the CSE 3901 course.  While Ruby has some aspects which you are familiar with from Java, it also has many key differences as well.  The goal of this tutorial is to highlight these differences and to apply what you know about Java to Ruby.  This document will provide the  basic nuances of the Ruby programming language as well as some examples.  Welcome to the wonderful world of Ruby! 
  </p>
  <br />
  <p class="sectionTitle">Data Types and Variables</p>
  <img class=" rubySide smallImg" src="images/class.gif" alt= "ruby class tree">
  <p class="writing">
  	The first key aspect of Ruby is to understand that everything is an object. It is object-oriented like Java, but everything is an object. This includes the simple "integer primatives" (in Ruby they are objects from the Fixnum class) you are accustomed to in Java.  Also in Ruby, there are classes as well.  Ruby uses classes for inheritance.  The image to the right is an execellent illustration of object/class heiherarchy.
  	Classes will be expanded upon soon.  One of the first things you were taught in the software sequence was each primative variable has a data type, which must be declared when the variable is declared and initialized. In Ruby, there are no data types! See the example below: 
  </p>
  <pre><code class="ruby">
  x = 31
  puts x => 31
  x = "doggie"
  puts x => doggie
  </code></pre>
  <p class="writing">  
  	As you can see, the variable x was first made an int, then later changed to a string. There is no type declaration at any point and was changed very easily! Ruby has classes that are similar to Java primative data types among other and more:
  </p>
  <table>
  	<tr>
  		<th> Java</th><th>Ruby</th>
  	</tr>
  	<tr>
  		<td> String</td><td>String</td>
  	</tr>
  	<tr>
  		<td> int</td><td>Bignum,Fixnum</td>
  	</tr>
  	<tr>
  		<td> double</td><td>DNE</td>
  	</tr>
  	<tr>
  		<td> DNE</td><td>Ranges</td>
  	</tr>
  	<tr>
  		<td> null</td><td>nil</td>
  	</tr>
  	<tr>
  		<td> this</td><td>self</td>
  	</tr>
  	<tr>
  		<td> arrays of same type</td><td>mixed type</td>
  	</tr>
  	</table>
  <p class="writing">The last table row is a neat feature; let's look at an example.</p>
  <pre><code class="ruby">
  #Java
  	int [] myArr = [1,2,5,6,7];
  	#all values must be of same primitive type, and static length;
  #Ruby
  	myArr =[1,2,"three",[4,5,6]]
  	# arrays are dynamic, can contain different value types; integers, strings and an array all in one!
  </code></pre>
  <p class="writing">Another quick note: If you haven't noticed yet, ';' at the end of statements in Ruby are optional.  In fact, it is convention to leave them off!</p>
  <p class="sectionTitle"> Math and Logical Operators</p>
  <p class="writing">
  	The math and logical operations in Ruby work almost identical to they way they do in Java. The basic operators of '+,-,/,*' all work the same way.  '%' is modulo, not remainder, so take care to mind this difference.  When dividing a negative number (-1/3) in Ruby, it rounds towards -infinity, not 0.  A new operator is the '**' which is for exponents.  Logical operators have some old and new flavors to them.  Ruby still has the standard '||,&amp;&amp;,!,!=,==', and also adds the words 'and,or,not'; however, the words take lower precedence.  Ruby has arithmetic and logical concatination as follows '+=,-=,*=,/=,%=,**= &amp;&amp;,||='.  One missed feature in Ruby is the '++,--' operations. A big pitfall for new students making the transistion from Java to Ruby is the '==' and '.equal?'
  	operation.  Let's look at this example.
  </p>
  <pre><code class="ruby">
  	word1,word2 ="same","same"

  	word1 == word2 => true #Have the same value

  	word1.equal? word2 => false #different reference id

  	word1.eql? word2 => false #Checks for value and reference id

  	##Remember, everything is an object!

  	Note:  # is used for comments in Ruby, not // like in Java.
  </code></pre>
  <p class="sectionTitle">Comments</p>
  <p class="writing">
  Commenting code is annoying. Commenting code is time-consuming and dull. It can also save you from the terrible fate of looking at your code, realizing it doesn't work, and that you don't know how to fix it because you don't know which part of your code does what. Comments are important. Single-line comments are preceded by the # character. Multi-line comments are surrounded by "==begin" and "==end".
  </p>
  <pre>
  <code class="ruby">
  "This is executable code." #This is not.

  "This is also executable code."

=begin
    This is definitely not.
=end
  </code>
  </pre>
  <p class="sectionTitle">Strings</p>
  <p class="writing">
  Strings are an important data type, and have quite a bit of functionality associated with them. Strings are surrounded by "" or '', and have many methods that can be used with them. These include things like length, start_with?, include?, upcase, replace, slice, and others. Here are some examples of what they can do.
  <pre>
  <code class="ruby">
  s = "Go Bucks!"
  s.length      #=> 9
  s.start_with? "Go" #=> true
  s.upcase      #=> "GO BUCKS", s does not change
  s.split       #=> ["Go", "Bucks"] by default, splits at whitespace
  s.slice(3,2)  #=> "Bu"
  s.replace("O-H-I-O") #=> "O-H-I-O"
  </code>
  </pre>
  <p class="writing">
  String methods that return boolean values tend to end in the "?", methods that modify the string tend to end in "!", with the exception of replace. The slice method, which gets a substring, has a maximum of 2 parameters. The first is the position in the string to start the substring, and the second is how many characters wanted in the substring. In the example above, it started at position 3 ("B"), and gave 2 characters, resulting in "Bu".
  </p>
  <p class="writing">
  One important thing that can be done with strings is the evaluation of expressions within strings, which is known as interpolation. It can be done with the #{} operator, and any expression inside that expression is evaluated. This will only occur, however, if the string is enclosed within double quotes ("").
  </p>
  <pre>
  <code class="ruby">
  a = 2
  b = 4
  puts "2 + 4 = #{a+b}"

  #=> 2 + 4 = 6
  </code>
  </pre>
  <p>
  A pretty useful feature, to be sure. It can evaluate expressions between variables, too, as seen here.
  </p>
  <p class="sectionTitle">Ranges</p>
  <p class="writing">
  One interesting and useful class available in Ruby is the Range class. This defines a range of something, usually numbers, but can also be strings. They are defined by the syntax lowvalue..highvalue, such as 0..5 or 'bad'..'bag'. These will automatically include all integers between the limits, or all possible strings that go alphabetically between the limits. In this example, 0..5 includes 0, 1, 2, 3, 4, 5, and 'bad'..'bag' includes 'bad','bae','baf', and 'bag'.
  </p>
  <p class="writing">
  You can use 2 periods to make the bounds inclusive, or 3 to make them exclusive. The method to_a allows you to return an array made of all the values in the range.
  </p>
  <pre>
  <code class = "ruby">
  numrg = 0..5
  numrg.to_a #=> [0, 1, 2, 3, 4, 5]
  </code>
  </pre>
  <p class="writing">
  Another useful operator with ranges is the === operator. This test for inclusion within a range. Take a look:
  </p>
  <pre>
  <code class="ruby">
  numrg = 0..5

  numrg === 2 #=> true
  numrg === 6 #=> false
  </code>
  </pre>
  <p class="writing">
  Ranges are especially useful with things like for loops, which we will discuss later. So remember how to use ranges!
  </p>
  <p class="sectionTitle">Loops/Conditionals</p>
  <p class="writing">
  Flow control is important in any program that has to respond to any sort of input. Loops and conditional statements are how we accomplish that goal.
  </p>
  <p class="writing">
  The cool thing that Ruby's syntax allows is for you to write your loops and conditionals in a logical way that makes sense to your eyes, without all the special enclosing characters like {} or ().
  </p>
  <p class="writing">
  When you use loops or conditionals in Ruby, the code you want to enclose doesn't need to be put inside braces, and the boolean statement doesn't need parentheses. All you need to do is indent the code you want to enclose and you're good! Simple, looks great, and makes sense.
  </p>
  <pre>
  <code class = "ruby">
  n = 1
  while n &lt; 10 do
    n *= 2
    puts n
  end

  =>2
  =>4
  =>8
  =>16
  </code>
  </pre>
  <p class="writing">
  Ruby does not like frills and unnecessary writing, just like programmers! Ruby wants simple code, and only the bare minimum, as shown here.
  </p>
  <p class="sectionTitle">While Loops</p>
  <p class="writing">
  While loops are the same while loops you recognize from any other languages you have used. But as we all know, exact syntax is important with computers. The format of a while loop is actually somewhat flexible, as there are a couple different ways syntactically correct while loops can be written.
  </p>
  <pre>
  <code class="ruby">
  while condition [do]
    code
  end
  </code>
  </pre>
  <p class="writing">
  Note that the "end" statement is required, but the "do" is not! You must separate the conditional statement from the code with either a "do" or a newline and an indent.
  </p>
  <p class="writing">
  What if you have just one line of code to run? It seems like a waste to write out the whole structure. Ruby has the answer. You can use "while" as a modifier, using this syntax:
  </p>
  <pre>
  <code class="ruby">
  code while condition
  </code>
  </pre>
  <p class="writing">
  If you want a do-while loop (a loop that always executes once, then checks the condition), you can do that too! Be wary, though, it's not called a do-while loop anymore, as it uses the keyword "begin"
  </p>
  <pre>
  <code class="ruby">
  begin
    code
  end while condition
  </code>
  </pre>
  <p class="writing">
  Simple! Here is an example of those three loops at work:
  </p>
  <pre>
  <code class="ruby">
  i = 0

  #regular while loop
  while i &lt; 5
    i += 1
  end

  #1-line while modifier
  i += 1 while i &lt; 10

  #begin-while loop 
  begin
    i += 1
  end while i &lt; 15
  </code>
  </pre>
  <p class="writing">
  Another feature of Ruby is the "until" loop and modifier. "until" is essentially "while not", but makes more intuitive sense. You can use "until" in any way you could use "while".
  </p>
  <pre>
  <code class="ruby">
  i = 0

  #until loop
  until i > 5
    i += 1
  end
  </code>
  </pre>
  <p class="sectionTitle">For Loops/Each Loops</p>
  <p class="writing">
  For loops are also critical for most languages. Ruby's take on for loops is a bit different from what you're used to, however. The general syntax:
  </p>
  <pre>
  <code class="ruby">
  for var in expression
    code
  end
  </code>
  </pre>
  <p class="writing">
  That may have been a little confusing, especially to those of you who are used to writing for loops in C or Java. Like we've mentioned before, Ruby is very direct and minimalistic, so the condition and modifier have been removed, and it uses one expression to cover the number of times the loop will be executed. This is where the Range object comes in handy. Let's translate from C/Java to Ruby:
  </p>
  <pre>
  <code>
  #For-loop in Java
  for (i = 0; i &lt; 10; i++) {
    system.out.println(i);
  }

  #Same for-loop in Ruby
  for i in 0..9
    puts i
  end
  </code>
  </pre>
  <p class="writing">
  See the difference? Ruby again, is terse and simple. The Ruby loop assigns each value in the range 0..9 to i and runs the loop once for each different value. 
  </p>
  <p class="writing">
  Ruby also implements for-each loops, but also in a new way. An example:
  </p>
  <pre>
  <code class="ruby">
  #Each loop
  (0..9).each do |i|
    puts i
  end
  </code>
  </pre>
  <p class="writing">
  Notice the '|' operators surrounding the variable to be changed. This shows it being used with a range, but it can be used with other data types, such as arrays, as you'll see later on.

  </p>

  <p class="sectionTitle">If/Else Statements</p>
  <p class="writing">
  If loops are the backbone of efficiency, conditional statements are the backbone of choice and control. "If" statements allow the programmer to control different paths of the code. These statements are, of course, presented in Ruby without frills. Here's the basic syntax:
  </p>
  <pre>
  <code class="ruby">
  #If statement
  if condition [then]
    code
  end
  </code>
  </pre>
  <p class="writing">
  Look familiar? Almost the same as a while loop. "If" statements tend to be very similar to while loops in syntax. Like the [do] with a while loop, the [then] is optional, and can be replaced by a newline and an indent. Of course, you can use the "elsif" and "else" keywords to create more cases and the default case. Like so:
  </p>
  <pre>
  <code class="ruby">
  #If-elsif-else example
  if i == 0
    puts "i is zero"
  elsif i &lt; 0
    puts "i is negative"
  else
    puts "i is positive"
  end

  </code>
  </pre>
  <p class="writing">
  Of course, you'll notice that it uses "elsif", instead of "else if". No unnecessary writing allowed. The "elsif" syntax is the same as "if" syntax, and "else" syntax is as simple as can be.
  </p>
  <p class="writing">
  Just like while loops, you can use if as a modifier for 1-line statements.
  </p>
  <pre>
  <code class="ruby">
  #If as a modifier
  puts "i = 0" if i == 0
  </code>
  </pre>
  <p class="writing">
  However, you should not use "elsif" or "else" when using "if" as a modifier. 
  </p>
  <p class="writing">
  Like "until" for while loops, there is a keyword for an "if not" statement, "unless". You can use "unless" the same way you would use an "if" statement. If you really want to, you can use "else" with an "unless" statement, but it is not recommended, since you could replace that with an if-else structure.
  </p>
  <pre>
  <code class="ruby">
  #unless statement
  unless i &lt;= 0
    puts "i is positive"
  end
  </code>
  </pre>
  <p class="writing">
  If-elsif-else structures are vital, so use them well!
  </p>
  <p class="sectionTitle">Case Statements</p>
  <p class="writing">
  If you've coded in C, Java, or many other languages, you're probably familiar with switch-case statements. Ruby has case-when statements, which do all of the same things.
  </p>
  <p class="writing">
  Here are the differences with keywords. Case statements start with the "case" keyword, with the variable to be used. The possible values start with a "when". All other values fall under the "else" statement. Here's an example:
  </p>
  <pre>
  <code class="ruby">
  #case statement

  case weather
  when "snowy"
  	puts "It's too cold!"
  when "rainy"
  	puts "It's too wet!"
  when "windy"
    puts "It's too blustery!"
  else
    puts "It's a beautiful day!"
  end
  </code>
  </pre>
  <p class="writing">
  Now that you've seen it, it makes sense. Remember, no parentheses needed, no braces needed, nothing more than is necessary. 
  </p>
  <p class="sectionTitle">Functions</p>
  <p class="writing">
  Writing functions in Ruby is simple. Like many other things in Ruby, it has less wordiness than functions you're used to in other languages.
  </p>
  <p class="writing">
  Functions are defined by the "def" keyword. Like other structures that enclose code, it ends with an "end". As Ruby has dynamic data typing, parameters do not have a defined type.
  </p>
  <pre>
  <code class="ruby">
  #function definition
  def func(x, y)
    x + y
  end
  </code>
  </pre>
  <p>
  One thing you likely noticed is that there was no return value in the function. That's because you don't need to explicitly define a return in Ruby functions! If no return is defined, it will return the value of the last statement in the function.
  </p>
  <p>
  Calling a function is very simple as well. When calling a function, parentheses can be omitted, and usually are. The only time parentheses are generally used when calling a function is when it has arguments, and there is chaining. Here's an example
  </p>
  <pre>
  <code class="ruby">
  #calling a function
  x = func 2,5

  #calling a function with parameters and chaining
  b = func(2,5).equal? 7
  </code>
  </pre>
  <p class="sectionTitle">Classes</p>
  <p class="writing">
  	The best way to talk about creating your own class in Ruby is to just give an example.  It is very easy, and Ruby provides shortcuts so it is even simpler!
  </p>
  <pre>
  <code class="ruby">
  	#class Cat

  	class Cat
  		def initialize #needed to create a new object of the class.
  			@name = nil #@name and @color are instance variables!
  			@color = "orange"
  		end
  		def setName(name)
  			@name =name
  		end
  		def meow
  			puts "meow"
  		end
  		def pur
  			puts "puuur-puurr"
  		end
  	end  	


  	kitten = Cat.new  #creates new cat
  	kitten.setName("Mr. Jingles") # gives cat a name.
  </code>
  </pre>
  <p class="writing">
  	As you can see, it is fairly simple to make a class!  Classes generally start with an upper case letter.  The word "initialize" is used as a constructor to create a new object of that class. In the example above you see some functions that are declared using def and the name of the function (such as setNAme, meow and pur). With Ruby, the getter and setter methods(functions) can be much easier. Here is how to do it; you use attribute_accessors!
  </p>
  <pre>
  <code class="ruby">
  	attr_reader :color #this allows you to display the name
  	attr_writer :name #this allows you to set the name, will replace setName in above example
  	attr_accessor :name #this allows to do both!

  	#replace
  		def setName(name)
  			@name =name
  		end
  	#attr_accessor :name to get....
  	class Cat
  		def initialize 
  			@name = nil 
  			@color = "orange"
  		end
  		def meow
  			puts "meow"
  		end
  		def pur
  			puts "puuur-puurr"
  		end
  		attr_accessor :name
  	end  
  	
  	#now you can read and write with...
  	kitten.name = "Mr. Jingles"
  	kitten.name => "Mr.Jingles"
  </code>
  </pre>
  <p class="writing">
  	Use the attr_accessors, it shortens the code and helps readability! Another great feature about classes in Ruby is that they can <strong> ALWAYS</strong> be expanded upon! Say you want to add another method to the cat class:
  </p>
  <pre>
  <code class="ruby">
  	#All you need to do is the following...
  	class Cat
  		def scratch
  			puts "HISS, SWIPE!"
  		end
  	end

  	#Cat now has this method!
  </code>
  </pre>
  <p class="writing">
  	You can add on to existing Ruby classes as well! You are not limited to just user defined classes.  A draw back to Ruby is there is no method overloading.  There is no distinction between the number of arguements that are passed.
  </div><!-- .welcome -->